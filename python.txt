运行时编译的一门语言

整数可以处理任意大小的整数.对整数以及浮点数大小没有限制。
print(r'\\\t\\')是不转义的

通常用全部大写的变量名表示常量(跟java一样)，没有机制保证常量不会发生改变

1行代码能实现的功能，决不写5行代码。请始终牢记，代码越少，开发效率越高

Unicode把所有的语言都统一到一套编码里。ASCII编码是1个字节，而Unicode编码是2个字节，
本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。
UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，
常用的英文字母被编码成1个字节，汉字通常是3个字节，
只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，
用UTF-8编码就能节省空间。UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。

计算机系统通用的字符编码工作方式：编码的一个转化对用户来说是黑盒
在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。
用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件
浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器


由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes



为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。
此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。


字符串：
python3中字符串是以Unicode编码的


序列包括 列表和元组、字符串
列表通用算法：
    len、s[0]、+、s[:]、嵌套
在python中每一个对象都可以分为不可变性或者可变性。在核心类型中，数字、字符串、元组是不可变的，
列表、字典确实自由改变的

迭代：列表[]、元组()、字符串，字典{}

    d={'a':1,'b':2,'c':4}
    for key in  d:
        print(key)

    for value in d.values():
        print(value)

    for k,v in d.items():
        print(k +'=>'+str(v))

list和tuple(元组):
    list 有序集合,没有数据类型的区别。这点跟java不一样
    跟java的数组差不多，可变的


tuple:
    指向不可变,所以代码更安全。如果可能尽量用tuple代替list
    t=(1) 按小括号记
    理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变
    tuple虽然是不变对象，但试试把(1, 2, 3)和(1, [2, 3])放入dict或set中，tuple就是可变的了

dict(字典) 与java中的map相似
    和list比较，dict有以下几个特点：
    1. 查找和插入的速度极快，不会随着key的增加而增加；
    2. 需要占用大量的内存，内存浪费多。
    而list相反：
    1. 查找和插入的时间随着元素的增加而增加；
    2. 占用空间小，浪费内存很少。

    dict的key必须是不可变的对象，

set集合  不可重复,与java很相似
    无序不重复，因此，两个set可以做数学意义上的交集、并集等操作
    同样不可以放入可变对象，因为无法判断两个可变对象是否相等


函数
    数据类型的强转跟java不太一样
    java (int)128.0;
    python int(128.0)
            str(1.23)

    可以将函数赋值给变量

    如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。
    return None可以简写为return。

    空函数
    如果想定义一个什么事也不做的空函数，可以用pass语句：
    def nop():
        pass
    pass可以用来作为占位符

    定义函数时，需要确定函数名和参数个数；
    如果有必要，可以先对参数的数据类型做检查；
    函数体内部可以用return随时返回函数结果；
    函数执行完毕也没有return语句时，自动return None。    java  void不会自动  java8 是None避免空指针异常
    函数可以同时返回多个值，但其实就是一个tuple。

函数参数
    除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数

    默认参数：定义默认参数要牢记一点：默认参数必须指向不变对象！
    一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；
    二是如何设置默认参数。
    当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。
    使用默认参数有什么好处？最大的好处是能降低调用函数的难度

    可变参数：
    所以，我们把函数的参数改为可变参数：numbers list tuple
    def calc(*numbers):
    sum = 0
    for n in numbers:
    sum = sum + n * n
    return sum
    定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，
    因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数
    所以Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去


    #关键字参数
        def person(name,age,**kw):
            print('name:',name,'age:',age,'other:',kw)
     #关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict
        person('Michael',30)
        person('Bob',30,city='Beijing')
    #关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求



    Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。
    默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！
    要注意定义可变参数和关键字参数的语法：
    *args是可变参数，args接收的是一个tuple；
    **kw是关键字参数，kw接收的是一个dict。
    以及调用函数时如何传入可变参数和关键字参数的语法：
    可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；
    关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。
    使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。
    命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。
    定义命名的关键字参数不要忘了写分隔符*，否则定义的将是位置参数。

#递归函数  凭心而论目前不太说的明白函数与方法的区别，只知道两者相似。
自己的理解，对于函数式编程他们称之为函数，对于非函数编程他们称之为方法
    使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出

#迭代

一类是集合数据类型，如list、tuple、dict、set、str等；
一类是generator，包括生成器和带yield的generator function。
这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。

可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。

生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。
把list、dict、str等Iterable变成Iterator可以使用iter()函数：
>>> isinstance(iter([]), Iterator)
True
>>> isinstance(iter('abc'), Iterator)
True


那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：
>>> from collections import Iterable
>>> isinstance('abc', Iterable) # str是否可迭代
True
>>> isinstance([1,2,3], Iterable) # list是否可迭代
True
>>> isinstance(123, Iterable) # 整数是否可迭代

任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。


你可能会问，为什么list、dict、str等数据类型不是Iterator？
这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。
Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。


凡是可作用于for循环的对象都是Iterable类型；
凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；
集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。
Python的for循环本质上就是通过不断调用next()函数实现的，例如：
for x in [1, 2, 3, 4, 5]:
pass
实际上完全等价于：
# 首先获得Iterator对象:
it = iter([1, 2, 3, 4, 5])
# 循环:
while True:
try:
# 获得下一个值:
x = next(it)
except StopIteration:
# 遇到StopIteration就退出循环
break

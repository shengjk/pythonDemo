#!/usr/bin/env python3# -*- coding: utf-8 -*-# Create by shengjk1 on  2018/5/14# name = input("name")# print ((name)## num = int(input("age"))# print ((num)## result = eval(input("enter a expression:"))# print ((result)## while True:#     try:#         x = int(input("age:"))#         break#     except BaseException as e:#         print (("that is not a valid number!" ,e)#     finally:#         print (("Attmpted Input")path = '/Users/iss/sourceCode/pyProject/pythonDemo/clsself.py'# python3 'ascii' codec can't decode byte 0xe6 in position 0f = open(path, 'r', encoding='latin1')f.read()f.close()f = open("./test.txt", 'w')f.write("hahahhh")f.close()# with 自动关闭流with open(path, 'r') as f:    print (f.read(4))    # print ((bytes.decode(f.read().encode("utf-8")))camelot_lines = []with open(path) as f:    for line in f:        camelot_lines.append(line.strip())print (camelot_lines)import unicodecsvimport pandas as pddef read_csv(filename):    with open(filename, 'rb') as f:        reader = unicodecsv.DictReader(f)        return list(reader)# daily_engagement = read_csv('/Users/iss/Desktop/test.csv')# print (daily_engagement[0])# print (type(daily_engagement[0]))#### daily_engagement = pd.read_csv("/Users/iss/Desktop/test.csv")# print (daily_engagement["acct"].unique())import numpy as np# First 20 countries with employment datacountries = np.array([    'Afghanistan', 'Albania', 'Algeria', 'Angola', 'Argentina',    'Armenia', 'Australia', 'Austria', 'Azerbaijan', 'Bahamas',    'Bahrain', 'Bangladesh', 'Barbados', 'Belarus', 'Belgium',    'Belize', 'Benin', 'Bhutan', 'Bolivia',    'Bosnia and Herzegovina'])# Employment data in 2007 for those 20 countriesemployment = np.array([    55.70000076, 51.40000153, 50.5, 75.69999695,    58.40000153, 40.09999847, 61.5, 57.09999847,    60.90000153, 66.59999847, 60.40000153, 68.09999847,    66.90000153, 53.40000153, 48.59999847, 56.79999924,    71.59999847, 58.40000153, 70.40000153, 41.20000076])# Change False to True for each block of code to see what it does# Accessing elementsif True:    print (countries[0])    print (countries[3])# Slicingif True:    print (countries[0:3])    print (countries[:3])    print (countries[17:])    print (countries[:])# Element typesif True:    print (countries.dtype)    print (employment.dtype)    print (np.array([0, 1, 2, 3]).dtype)    print (np.array([1.0, 1.5, 2.0, 2.5]).dtype)    print (np.array([True, False, True]).dtype)    print (np.array(['AL', 'AK', 'AZ', 'AR', 'CA']).dtype)# Loopingif True:    for country in countries:        print ('Examining country {}'.format(country))    for i in range(len(countries)):        country = countries[i]        country_employment = employment[i]        print ('Country {} has employment {}'.format(country,                                                     country_employment))# Numpy functionsif True:    print (employment.mean())    print (employment.std())    print (employment.max())    print (employment.sum())max_value = employment.max()print('======', employment.argmax())def max_employment(countries, employment):    '''    Fill in this function to return the name of the country    with the highest employment in the given employment    data, and the employment in that country.    '''    max_country = None      # Replace this with your code    max_value = None   # Replace this with your code    return (max_country, max_value)import numpy as np# Change False to True for each block of code to see what it does# Arithmetic operations between 2 NumPy arraysif True:    a = np.array([1, 2, 3, 4])    b = np.array([1, 2, 1, 2])    print (a + b)    print (a - b)    print (a * b)    print (a / b)    print (a ** b)# Arithmetic operations b )etween a NumPy array and a single numberif True:    a = np.array([1, 2, 3, 4])    b = 2    print()    print (a + b)    print (a - b)    print (a * b)    print (a / b)    print (a ** b)# Logical operations with NumPy arraysif True:    a = np.array([True, True, False, False])    b = np.array([True, False, True, False])    # 如果是数字的话，按位与按位或    print()    print (a & b)    print (a | b)    print (~a)    print (a & True)    print (a & False)    print (b | True)    print (b | False)# Comparison operations between 2 NumPy Arraysif True:    a = np.array(['a', 'v', 'ac', 'df', 'ff'])    b = np.array(['a', 'v', 'ac', 'df', 'ff'])    # b = np.array([5, 4, 3, 2, 1])    print()    print (a > b)    print (a >= b)    print (a < b)    print (a <= b)    print (a == b)    print (a != b)# Comparison operations between a NumPy array and a single numberif True:    a = np.array([1, 2, 3, 4])    b = 2    print (a > b)    print (a >= b)    print (a < b)    print (a <= b)    print (a == b)    print (a != b)# First 20 countries with school completion datacountries = np.array([    'Algeria', 'Argentina', 'Armenia', 'Aruba', 'Austria', 'Azerbaijan',    'Bahamas', 'Barbados', 'Belarus', 'Belgium', 'Belize', 'Bolivia',    'Botswana', 'Brunei', 'Bulgaria', 'Burkina Faso', 'Burundi',    'Cambodia', 'Cameroon', 'Cape Verde'])# Female school completion rate in 2007 for those 20 countriesfemale_completion = np.array([    97.35583, 104.62379, 103.02998, 95.14321, 103.69019,    98.49185, 100.88828, 95.43974, 92.11484, 91.54804,    95.98029, 98.22902, 96.12179, 119.28105, 97.84627,    29.07386, 38.41644, 90.70509, 51.7478, 95.45072])# Male school completion rate in 2007 for those 20 countriesmale_completion = np.array([    95.47622, 100.66476, 99.7926, 91.48936, 103.22096,    97.80458, 103.81398, 88.11736, 93.55611, 87.76347,    102.45714, 98.73953, 92.22388, 115.3892, 98.70502,    37.00692, 45.39401, 91.22084, 62.42028, 90.66958])def overall_completion_rate(female_completion, male_completion):    '''    Fill in this function to return a NumPy array containing the overall    school completion rate for each country. The arguments are NumPy    arrays giving the female and male completion of each country in    the same order.    '''    return (male_completion + female_completion) / 2# 数据标准化  通常将各数据点转化为相对于平均值的标准偏差值import numpy as np# First 20 countries with employment datacountries = np.array([    'Afghanistan', 'Albania', 'Algeria', 'Angola', 'Argentina',    'Armenia', 'Australia', 'Austria', 'Azerbaijan', 'Bahamas',    'Bahrain', 'Bangladesh', 'Barbados', 'Belarus', 'Belgium',    'Belize', 'Benin', 'Bhutan', 'Bolivia',    'Bosnia and Herzegovina'])# Employment data in 2007 for those 20 countriesemployment = np.array([    55.70000076, 51.40000153, 50.5, 75.69999695,    58.40000153, 40.09999847, 61.5, 57.09999847,    60.90000153, 66.59999847, 60.40000153, 68.09999847,    66.90000153, 53.40000153, 48.59999847, 56.79999924,    71.59999847, 58.40000153, 70.40000153, 41.20000076])# Change this country name to change what country will be printed when you# click "Test Run". Your function will be called to determine the standardized# score for this country for each of the given 5 Gapminder variables in 2007.# The possible country names are available in the Downloadables section.country_name = 'United States'def standardize_data(values):    '''    Fill in this function to return a standardized version of the given values,    which will be in a NumPy array. Each value should be translated into the    number of standard deviations that value is away from the mean of the data.    (A positive number indicates a value higher than the mean, and a negative    number indicates a value lower than the mean.)    '''    standardize_value = (values - values.mean()) / values.std()    return standardize_value'''+与+=不一样的+=原位运算   +不是原位运算'''# Change False to True for each block of code to see what it does# Using index arraysif True:    a = np.array([1, 2, 3, 4])    b = np.array([True, True, False, False])    print (a[b])    print(a[np.array([True, False, True, False])])    a = np.array([1, 2, 1, 2])    b = np.array(a >= 2)    print(a[b])    print(a[a >= 2])    a = np.array([1, 2, 3, 4, 5])    b = np.array([1, 2, 3, 2, 1])    print(a == b)    print(b == 2)    print(a[b == 2])time_spent = np.array([    12.89697233, 0., 64.55043217, 0.,    24.2315615, 39.991625, 0., 0.,    147.20683783, 0., 0., 0.,    45.18261617, 157.60454283, 133.2434615, 52.85000767,    0., 54.9204785, 26.78142417, 0.])# Days to cancel for 20 studentsdays_to_cancel = np.array([    4, 5, 37, 3, 12, 4, 35, 38, 5, 37, 3, 3, 68,    38, 98, 2, 249, 2, 127, 35])print(days_to_cancel[days_to_cancel >= 7])print(time_spent[days_to_cancel >= 7])# np跟python原生数组是不一样的，np更像是一种向量# [100   2   3   4   5   6]a = np.array([1, 2, 3, 4, 5, 6])slice = a[:3]slice[0] = 100print(a)# [1, 2, 3, 4, 5, 6]a = [1, 2, 3, 4, 5, 6]slice = a[:3]slice[0] = 100print(a)# python中booleam类型可以进行相加True + True == 2  # True# Pandas的Series与numpy 中的array类似countries = ['Albania', 'Algeria', 'Andorra', 'Angola', 'Antigua and Barbuda',             'Argentina', 'Armenia', 'Australia', 'Austria', 'Azerbaijan',             'Bahamas', 'Bahrain', 'Bangladesh', 'Barbados', 'Belarus',             'Belgium', 'Belize', 'Benin', 'Bhutan', 'Bolivia']life_expectancy_values = [74.7, 75., 83.4, 57.6, 74.6, 75.4, 72.3, 81.5, 80.2,                          70.3, 72.1, 76.4, 68.1, 75.2, 69.8, 79.4, 70.8, 62.7,                          67.3, 70.6]gdp_values = [1681.61390973, 2155.48523109, 21495.80508273, 562.98768478,              13495.1274663, 9388.68852258, 1424.19056199, 24765.54890176,              27036.48733192, 1945.63754911, 21721.61840978, 13373.21993972,              483.97086804, 9783.98417323, 2253.46411147, 25034.66692293,              3680.91642923, 366.04496652, 1175.92638695, 1132.21387981]life_expectancy = pd.Series(life_expectancy_values)gdp = pd.Series(gdp_values)if True:    print(life_expectancy[0])    print('=======', gdp[3:6])    print('=======', type(gdp[3:6]))if True:    for country_life_expectancy in life_expectancy:        print(country_life_expectancy)if True:    print('======', life_expectancy.mean())    print(life_expectancy.std())    print(gdp.max())    print(gdp.sum())if True:    a = pd.Series([1, 2, 3, 4])    b = pd.Series([1, 2, 1, 2])    print(a + b)    print(a * 2)    print(a >= 3)    print(a[a >= 3])print(gdp)both_above = ((gdp > gdp.mean()) & (life_expectancy > life_expectancy.mean()))both_below = ((gdp < gdp.mean()) & (life_expectancy < life_expectancy.mean()))is_same_direction = both_above | both_belowprint(both_below)a = np.array([1, 2, 3, 4])b = pd.Series([1, 2, 3, 4])print(b.describe())life_expectancy = pd.Series([74.7, 75, 83.4, 57.6],                            index=['Albania', 'Algeria',                                   'Andorra', 'Angola'])print(life_expectancy)print(life_expectancy[0])  # 根据位置来取数据的print(life_expectancy.iloc[0])  # 根据位置来取数据的print(life_expectancy.loc['Albania'])print(a[0])print('===============', life_expectancy.argmax)'''NumPy数组就是增强版的Python列表，Pandas Series就像列表和字典的合集在列表中元素按顺序排列，需要通过位置获取 Series也这样字典按index取值，Series也是这样Series有索引,按索引匹配，而NumPy按位置匹配'''s1 = pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])s2 = pd.Series([10, 20, 30, 40], index=['a', 'b', 'c', 'd'])print (s1 + s2)s1 = pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])s2 = pd.Series([10, 20, 30, 40], index=['b', 'd', 'a', 'c'])print (s1 + s2)s1 = pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])s2 = pd.Series([10, 20, 30, 40], index=['c', 'd', 'e', 'f'])print (s1 + s2)s1 = pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])s2 = pd.Series([10, 20, 30, 40], index=['e', 'f', 'g', 'h'])sum = s1 + s2print ('============', sum.dropna())print(s1.add(s2, fill_value=0))if True:    s = pd.Series([1, 2, 3, 4, 5])    def add_one(x):        return x + 1    print (s.apply(add_one))names = pd.Series([    'Andre Agassi',    'Barry Bonds',    'Christopher Columbus',    'Daniel Defoe',    'Emilio Estevez',    'Fred Flintstone',    'Greta Garbo',    'Humbert Humbert',    'Ivan Ilych',    'James Joyce',    'Keira Knightley',    'Lois Lane',    'Mike Myers',    'Nick Nolte',    'Ozzy Osbourne',    'Pablo Picasso',    'Quirinus Quirrell',    'Rachael Ray',    'Susan Sarandon',    'Tina Turner',    'Ugueth Urbina',    'Vince Vaughn',    'Woodrow Wilson',    'Yoji Yamada',    'Zinedine Zidane'])import seaborn as sns# The following code reads all the Gapminder data into Pandas DataFrames. You'll# learn about DataFrames next lesson.path = '/Users/iss/sourceCode/pyProject/pythonDemo/jqxi/'employment = pd.read_csv(path + 'employment-above-15.csv', index_col='Country')female_completion = pd.read_csv(    path + 'female-completion-rate.csv',    index_col='Country')life_expectancy = pd.read_csv(    path + 'life-expectancy.csv',    index_col='Country')gdp = pd.read_csv(path + 'gdp-per-capita.csv', index_col='Country')# The following code creates a Pandas Series for each variable for the United States.# You can change the string 'United States' to a country of your choice.employment_us = employment.loc['United States']female_completion_us = female_completion.loc['United States']life_expectancy_us = life_expectancy.loc['United States']gdp_us = gdp.loc['United States']# Uncomment the following line of code to see the available country names# print employment.index.values# Use the Series defined above to create a plot of each variable over time for# the country of your choice. You will only be able to display one plot at a time# with each "Test Run".import matplotlib.pyplot as pltemployment_us.plot()print(employment_us)# plt.show()# 二维数组'''numpy中是ndarrayPandas:DataFrame 优于numpy每一列可以是不同的值   基本上索引都是要存在的算术平均值将计算所有值得平均值，不考虑其所在的行和列也可以计算每一行的平均值'''import numpy as np# Subway ridership for 5 stations on 10 different daysridership = np.array([    [0, 0, 2, 5, 0],    [1478, 3877, 3674, 2328, 2539],    [1613, 4088, 3991, 6461, 2691],    [1560, 3392, 3826, 4787, 2613],    [1608, 4802, 3932, 4477, 2705],    [1576, 3933, 3909, 4979, 2685],    [95, 229, 255, 496, 201],    [2, 0, 1, 27, 0],    [1438, 3785, 3589, 4174, 2215],    [1342, 4043, 4009, 4665, 3033]])# Change False to True for each block of code to see what it does# Accessing elementsif True:    print("=====================")    print(ridership[1, 3])  # a[1][3]    print (ridership[1:3, 3:5])    print (type(ridership[1, :]))# Vectorized operations on rows or columnsif True:    print("=====================")    print (ridership[0, :] + ridership[1, :])    print(ridership[:, 0])    print(ridership[:, 1])    print (ridership[:, 0] + ridership[:, 1])# Vectorized operations on entire arraysif True:    print("=====================")    a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])    b = np.array([[1, 1, 1], [2, 2, 2], [3, 3, 3]])    print (a + b)print(ridership[0, :].max())print(ridership[0, :].argmax())print(ridership[:, 3].mean())print(ridership.mean())# 每一行的平均值，每一列的平均值print(ridership.mean(axis=0))  # 每一列的平均值print(ridership.mean(axis=1))  # 每一行的平均值enrollments_df = pd.DataFrame({    'accout_key': [448, 448, 448, 448],    'status': ['canceld', 'canceld', 'canceld', 'canceld']})# 会取每一列的平均值，并忽略掉其他值print(enrollments_df.mean())ridership_df = pd.DataFrame({    'R003': [0, 1478, 1613, 1560, 1608, 1576, 95, 2],    'R004': [0, 3877, 4088, 3392, 4802, 3933, 229, 0]}, index=['05-01-11', '05-02-11', '05-03-11', '05-04-11',          '05-05-11', '05-06-11', '05-07-11', '05-08-11'])print(ridership_df)# 按照索引获取某一行print(ridership_df.loc['05-01-11', 'R003'])print("=======================")# 按照位置获取print(ridership_df.iloc[0, 1])# 获取某一列的内容print(type(ridership_df['R004']))print("============================")print(ridership_df.values)ridership_df = pd.DataFrame(    data=[[0, 0, 2, 5, 0],          [1478, 3877, 3674, 2328, 2539],          [1613, 4088, 3991, 6461, 2691],          [1560, 3392, 3826, 4787, 2613],          [1608, 4802, 3932, 4477, 2705],          [1576, 3933, 3909, 4979, 2685],          [95, 229, 255, 496, 201],          [2, 0, 1, 27, 0],          [1438, 3785, 3589, 4174, 2215],          [1342, 4043, 4009, 4665, 3033]],    index=['05-01-11', '05-02-11', '05-03-11', '05-04-11', '05-05-11',           '05-06-11', '05-07-11', '05-08-11', '05-09-11', '05-10-11'],    columns=['R003', 'R004', 'R005', 'R006', 'R007'])# Change False to True for each block of code to see what it doesprint(ridership_df)# DataFrame creationif False:    # You can create a DataFrame out of a dictionary mapping column names to    # values    df_1 = pd.DataFrame({'A': [0, 1, 2], 'B': [3, 4, 5]})    print (df_1)    # You can also use a list of lists or a 2D NumPy array    df_2 = pd.DataFrame([[0, 1, 2], [3, 4, 5]], columns=['A', 'B', 'C'])    print (df_2)# Accessing elementsif False:    print('================')    print (ridership_df.iloc[0])    print('================')    print (ridership_df.loc['05-05-11'])    print('================')    print (ridership_df['R003'])    print('================')    print (ridership_df.iloc[1, 3])    print('================')# Accessing multiple rowsif False:    print (ridership_df.iloc[1:4])# Accessing multiple columnsif False:    print (ridership_df[['R003', 'R005']])# Pandas axisif True:    df = pd.DataFrame({'A': [0, 1, 2], 'B': [3, 4, 5]})    print(df)    # 每一列的sum    # print (df.sum())    # 每一行的sum    # print (df.sum(axis=1))    # 每一列的sum    # print (df.sum(axis=0))    # print (df.values.sum())    # print(df.mean())    print('=============')    print(df.iloc[0].argmax())sumwat_df = pd.read_csv(    '/Users/iss/sourceCode/pyProject/pythonDemo/jqxi/nyc-subway-weather.csv')# print(sumwat_df.head())# print(sumwat_df.describe())if False:    df1 = pd.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6], 'c': [7, 8, 9]})    df2 = pd.DataFrame(        {'a': [10, 20, 30], 'b': [40, 50, 60], 'c': [70, 80, 90]})    print(df1)    print (df1 + df2)# Adding DataFrames with overlapping row indexesif True:    df1 = pd.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6], 'c': [7, 8, 9]},                       index=['row1', 'row2', 'row3'])    df2 = pd.DataFrame({'a': [10, 20, 30], 'b': [40, 50, 60], 'c': [                       70, 80, 90]}, index=['row4', 'row3', 'row2'])    print(df1)    print(df2)    print (df1 + df2)# --- Quiz ---# Cumulative entries and exits for one station for a few hours.entries_and_exits = pd.DataFrame({    'ENTRIESn': [3144312, 3144335, 3144353, 3144424, 3144594,                 3144808, 3144895, 3144905, 3144941, 3145094],    'EXITSn': [1088151, 1088159, 1088177, 1088231, 1088275,               1088317, 1088328, 1088331, 1088420, 1088753]})print(entries_and_exits)# 位移函数print(entries_and_exits.shift(1))print((entries_and_exits - entries_and_exits.shift(1)).fillna(0))# 自定义函数 applymap()# DataFrame applymap()  从DataFrame中取出一个元素并返回一个新的元素# 然后对DataFrame中的每一个元素调用(apply)这个函数f从而获得新的DataFrame# DataFrame中的apply函数是每一列调用函数#if True:    df = pd.DataFrame({        'a': [1, 2, 3],        'b': [10, 20, 30],        'c': [5, 10, 15]    })    def add_one(x):        return x + 1    print(df)    print (df.applymap(add_one))grades_df = pd.DataFrame(    data={'exam1': [43, 81, 78, 75, 89, 70, 91, 65, 98, 87],          'exam2': [24, 63, 56, 56, 67, 51, 79, 46, 72, 60]},    index=['Andre', 'Barry', 'Chris', 'Dan', 'Emilio',           'Fred', 'Greta', 'Humbert', 'Ivan', 'James'])# Change False to True for this block of code to see what it does# DataFrame apply()if True:    def convert_grades_curve(exam_grades):        # Pandas has a bult-in function that will perform this calculation        # This will give the bottom 0% to 10% of students the grade 'F',        # 10% to 20% the grade 'D', and so on. You can read more about        # the qcut() function here:        # http://pandas.pydata.org/pandas-docs/stable/generated/pandas.qcut.html        return pd.qcut(exam_grades,                       [0, 0.1, 0.2, 0.5, 0.8, 1],                       labels=['F', 'D', 'C', 'B', 'A'])    # qcut() operates on a list, array, or Series. This is the    # result of running the function on a single column of the    # DataFrame.    print (convert_grades_curve(grades_df['exam1']))    # qcut() does not work on DataFrames, but we can use apply()    # to call the function on each column separately    print (grades_df.apply(convert_grades_curve))    ''''    注意：为使计算能够正确进行，我们应该在 .std() 函数中将“ddof”参数的值设置为 0。    注意，计算得出的默认标准偏差类型在 numpy 的 .std() 和 pandas 的 .std() 函数之间是不同的。默认情况下，numpy 计算的是总体标准偏差，ddof = 0。另一方面，pandas 计算的是样本标准偏差，ddof = 1。如果我们知道所有的分数，那么我们就有了总体——因此，要使用 pandas 进行归一化处理，我们需要将“ddof”设置为 0。        '''    def standardize_column(colum):        return (colum - colum.mean()) / colum.std(ddof=0)    def standardize(df):        return df.apply(standardize_column)    print(standardize(grades_df))    print(grades_df.max())df = pd.DataFrame({    'a': [4, 5, 3, 1, 2],    'b': [20, 10, 40, 50, 30],    'c': [25, 20, 5, 15, 10]})# Change False to True for this block of code to see what it does#先算出每一行的，再往上套# DataFrame apply() - use case 2if True:    print (df.apply(np.mean))    print (df.apply(np.max))def second_largest(df):    '''    Fill in this function to return the second-largest value of each    column of the input DataFrame.    '''    return df.apply(second_largest_in_column)def second_largest_in_column(column):    sorted_column=column.sort_values(ascending=False)    return sorted_column.iloc[1]print(second_largest_in_column(df['a']))print('==================================')print(second_largest(df))#Series和DataFrame相加，会把索引相同的进行相加if False:    s = pd.Series([1, 2, 3, 4])    df = pd.DataFrame({        0: [10, 20, 30, 40],        1: [50, 60, 70, 80],        2: [90, 100, 110, 120],        3: [130, 140, 150, 160]    })    print (df)    print ('') # Create a blank line between outputs    print (df + s)# Adding a Series to a one-row DataFrameif False:    s = pd.Series([1, 2, 3, 4])    df = pd.DataFrame({0: [10], 1: [20], 2: [30], 3: [40]})    print (df)    print ('') # Create a blank line between outputs    print (df + s)# Adding a Series to a one-column DataFrameif False:    s = pd.Series([1, 2, 3, 4])    df = pd.DataFrame({0: [10, 20, 30, 40]})    print (df)    print ('') # Create a blank line between outputs    print (df + s)    print(df.add(s,axis='index'))# Adding when DataFrame column names match Series indexif True:    s = pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])    df = pd.DataFrame({        'a': [10, 20, 30, 40],        'b': [50, 60, 70, 80],        'c': [90, 100, 110, 120],        'd': [130, 140, 150, 160]    })    print (df)    print ('') # Create a blank line between outputs    print (df + s)# Adding when DataFrame column names don't match Series indexif True:    s = pd.Series([1, 2, 3, 4],index=[1,2,3,4])    df = pd.DataFrame({        0: [10, 20, 30, 40],        1: [50, 60, 70, 80],        2: [90, 100, 110, 120],        3: [130, 140, 150, 160]    })    print('')    print (df)    print ('================aaaa') # Create a blank line between outputs    print (df + s)    print('===============')    print(df.add(s,axis='index'))    s = pd.Series([1, 2, 3, 4])    df = pd.DataFrame({0: [10, 20, 30, 40]})    print ('') # Create a blank line between outputs    print (df + s)    print(df.add(s,axis='index'))if False:    s = pd.Series([1, 2, 3, 4])    df = pd.DataFrame({        0: [10, 20, 30, 40],        1: [50, 60, 70, 80],        2: [90, 100, 110, 120],        3: [130, 140, 150, 160]    })    print (df)    print("")    print (df + s)# Adding with axis='index'if True:    s = pd.Series([1, 2, 3, 4])    df = pd.DataFrame({        0: [10, 20, 30, 40],        1: [50, 60, 70, 80],        2: [90, 100, 110, 120],        3: [130, 140, 150, 160]    })    print (df)    print ('') # Create a blank line between outputs    print (df.add(s, axis='index'))    # The functions sub(), mul(), and div() work similarly to add()# Adding with axis='columns'if True:    s = pd.Series([1, 2, 3, 4])    df = pd.DataFrame({        0: [10, 20, 30, 40],        1: [50, 60, 70, 80],        2: [90, 100, 110, 120],        3: [130, 140, 150, 160]    })    print (df)    print (df.add(s, axis='columns'))    # The functions sub(), mul(), and div() work similarly to add()grades_df = pd.DataFrame(    data={'exam1': [43, 81, 78, 75, 89, 70, 91, 65, 98, 87],          'exam2': [24, 63, 56, 56, 67, 51, 79, 46, 72, 60]},    index=['Andre', 'Barry', 'Chris', 'Dan', 'Emilio',           'Fred', 'Greta', 'Humbert', 'Ivan', 'James'])print(grades_df)# print(grades_df.mean())#标准化# print((grades_df-grades_df.mean())/grades_df.std())#每一行上求平均值print('==================')print(grades_df.mean(axis='columns'))mean_diffs=grades_df.sub(grades_df.mean(axis='columns'),axis='index')print(mean_diffs)print(mean_diffs.div(grades_df.std(axis='columns'),axis='index'))import matplotlib.pyplot as pltimport seaborn as snsprint("====================== ")values = np.array([1, 3, 2, 4, 1, 6, 4])example_df = pd.DataFrame({    'value': values,    'even': values % 2 == 0,    'above_three': values > 3}, index=['a', 'b', 'c', 'd', 'e', 'f', 'g'])# Change False to True for each block of code to see what it does# Examine DataFrameprint (example_df)# Examine groupsif True:    grouped_data = example_df.groupby('even')    # The groups attribute is a dictionary mapping keys to lists of row indexes    print (grouped_data.groups)    print("================= ")    print (grouped_data.sum())    print(grouped_data.count())# Group by multiple columnsif False:    grouped_data = example_df.groupby(['even', 'above_three'])    print (grouped_data.groups)# Limit columns in resultif False:    grouped_data = example_df.groupby('even')    # You can take one or more columns from the result DataFrame    print (grouped_data.sum()['value'])    print ('\n') # Blank line to separate results    # You can also take a subset of columns from the grouped data before    # collapsing to a DataFrame. In this case, the result is the same.    print (grouped_data['value'].sum())# filename = '/datasets/ud170/subway/nyc_subway_weather.csv'# subway_df = pd.read_csv(filename)### Write code here to group the subway data by a variable of your choice, then### either print out the mean ridership within each group or create a plot.